<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Agent — Guarded v3 + Memory</title>
  <style>
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; margin: 16px; }
    h1 { margin: 0 0 12px; }
    button { font-size: 18px; padding: 10px 14px; margin: 8px 10px 8px 0; border-radius: 12px; border: none; background:#e5e7eb; }
    button.primary { background:#e0e7ff; }
    button[disabled] { opacity:.5 }
    #log { white-space: pre-wrap; font-family: ui-monospace, Menlo, monospace; background:#f7f7f7; padding:12px; border-radius:12px; }
    .card { background:#f3f4f6; padding:14px; border-radius:16px; margin: 12px 0; }
    input { font-size: 18px; padding: 10px 12px; width: 100%; box-sizing: border-box; border-radius: 12px; border: 1px solid #ddd; }
    .row { display:flex; gap:10px; align-items:center; margin: 6px 0; }
    .row button { margin: 0; }
    .pill { display:inline-block; background:#e5e7eb; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:6px; }
  </style>
</head>
<body>
  <h1>Voice Agent — Guarded v3 + Memory</h1>

  <div class="card">
    <div><strong>Your Memory (saved to server)</strong></div>
    <div id="uidRow" style="margin:8px 0 12px 0">
      <span>User ID:</span>
      <span id="uid" class="pill"></span>
    </div>

    <div class="row">
      <label style="min-width:80px">Name:</label>
      <input id="nameInput" placeholder="e.g., Alex Smith" />
      <button id="saveNameBtn">Save</button>
      <span id="nameSaveStatus" class="pill"></span>
    </div>

    <div class="row">
      <label style="min-width:80px">Kids:</label>
      <input id="kidsInput" placeholder="Comma-separated: Ava, Ben, Chris" />
      <button id="saveKidsBtn">Save</button>
      <span id="kidsSaveStatus" class="pill"></span>
    </div>
  </div>

  <div class="row">
    <button id="beepWA">Beep (WebAudio)</button>
    <button id="beepAT">Beep (AudioTag)</button>
  </div>
  <div class="row">
    <button id="nudge">Nudge audio</button>
    <button id="unlock">Unlock mic</button>
  </div>
  <div class="row">
    <button id="start" class="primary">Start voice agent</button>
    <button id="stop">Stop</button>
    <button id="force">Force reply</button>
  </div>

  <div style="margin:10px 0">Status: <strong id="status">idle</strong></div>
  <div id="log"></div>

  <!-- hidden audio sink for remote stream -->
  <audio id="remoteAudio" autoplay playsinline></audio>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);
  const log = (...args) => { console.log(...args); const s = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' '); $('log').textContent += s + "\n"; };
  const setStatus = (t) => $('status').textContent = t;

  // ---------- UI elements ----------
  const btnBeepWA  = $('beepWA');
  const btnBeepAT  = $('beepAT');
  const btnNudge   = $('nudge');
  const btnUnlock  = $('unlock');
  const btnStart   = $('start');
  const btnStop    = $('stop');
  const btnForce   = $('force');
  const nameInput  = $('nameInput');
  const kidsInput  = $('kidsInput');
  const nameSaveStatus = $('nameSaveStatus');
  const kidsSaveStatus = $('kidsSaveStatus');

  const remoteAudio = $('remoteAudio');

  // ---------- state ----------
  const MODEL = "gpt-4o-realtime-preview-2024-12-17";
  const VOICE = "verse";
  const baseURL = location.origin;

  // use URL param `userId` if present, otherwise a stable default you’ve used earlier
  const urlParams = new URLSearchParams(location.search);
  const userId = urlParams.get("userId") || "e6c9ba1f-b388-49e4-95d6-8fff48d954d7"; // your ID

  $('uid').textContent = userId;

  let pc = null;          // RTCPeerConnection
  let dc = null;          // data channel
  let micStream = null;   // MediaStream

  // ---------- memory UI ----------
  async function refreshMemoryUI() {
    try {
      const r = await fetch(`${baseURL}/memory/get?userId=${encodeURIComponent(userId)}`);
      const j = await r.json();
      log("memory/get:", j);
      nameInput.value = j?.memory?.name || "";
      kidsInput.value = Array.isArray(j?.memory?.kids) ? j.memory.kids.join(", ") : (j?.memory?.kids || "");
    } catch (e) {
      log("memory/get failed", e);
    }
  }

  async function saveMem(key, value) {
    const body = { userId, key, value };
    try {
      const r = await fetch(`${baseURL}/memory/set`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json();
      log("memory/set:", j);
      return j?.ok === true;
    } catch (e) {
      log("memory/set failed", e);
      return false;
    }
  }

  $('saveNameBtn').onclick = async () => {
    nameSaveStatus.textContent = "saving…";
    const ok = await saveMem("name", nameInput.value.trim());
    nameSaveStatus.textContent = ok ? "Saved" : "Failed";
  };
  $('saveKidsBtn').onclick = async () => {
    kidsSaveStatus.textContent = "saving…";
    const v = kidsInput.value.trim();
    const value = v.includes(",") ? v.split(",").map(s => s.trim()).filter(Boolean) : v;
    const ok = await saveMem("kids", value);
    kidsSaveStatus.textContent = ok ? "Saved" : "Failed";
  };

  // ---------- audio helpers ----------
  btnBeepWA.onclick = () => {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator(); o.frequency.value = 880;
    const g = ctx.createGain(); g.gain.value = 0.05;
    o.connect(g).connect(ctx.destination); o.start(); setTimeout(() => { o.stop(); }, 120);
    log("WebAudio beep");
  };
  btnBeepAT.onclick = () => {
    const a = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=");
    a.play(); log("AudioTag beep");
  };
  btnNudge.onclick = btnBeepWA.onclick;

  btnUnlock.onclick = async () => {
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log("microphone OK");
    } catch (e) {
      log("microphone error:", e);
    }
  };

  // ---------- WebRTC start/stop ----------
  btnStart.onclick = async () => {
    setStatus("starting…");
    $('log').textContent = "";

    try {
      if (!micStream) {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        log("microphone OK (auto)");
      }

      // 1) get a short-lived client secret from our server
      log("start: step 3/7 fetch /session");
      const s = await fetch(`${baseURL}/session?userId=${encodeURIComponent(userId)}`);
      const session = await s.json();
      if (!session?.client_secret?.value) throw new Error("No client secret from /session");
      log("start: got session");

      // 2) RTCPeerConnection
      log("start: step 5/7 create RTCPeerConnection");
      pc = new RTCPeerConnection();

      // play remote audio
      pc.ontrack = (ev) => {
        remoteAudio.srcObject = ev.streams[0];
      };

      // data channel for events
      dc = pc.createDataChannel("oai-events");
      dc.onopen = () => { log("datachannel open"); setStatus("listening"); };
      dc.onmessage = (e) => { log("event:", e.data.slice(0, 400)); };

      // send microphone
      micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

      // 3) SDP offer → OpenAI
      log("start: step 6/7 createOffer & setLocalDescription");
      const offer = await pc.createOffer({ offerToReceiveAudio: true });
      await pc.setLocalDescription(offer);

      log("start: step 7/7 POST offer to OpenAI");
      const resp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(MODEL)}&voice=${encodeURIComponent(VOICE)}`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${session.client_secret.value}`,
          "Content-Type": "application/sdp"
        },
        body: offer.sdp
      });

      const answer = { type: "answer", sdp: await resp.text() };
      await pc.setRemoteDescription(answer);

      pc.oniceconnectionstatechange = () => log("ice state:", pc.iceConnectionState);
      pc.onconnectionstatechange = () => log("pc state:", pc.connectionState);

      log("connected ✓ (speak, or tap Force reply)");
    } catch (e) {
      log("start error:", e.message || e.toString());
      setStatus("idle");
    }
  };

  btnStop.onclick = () => {
    try {
      if (dc && dc.readyState === "open") dc.close();
      if (pc) pc.close();
      dc = null; pc = null;
      if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
      remoteAudio.srcObject = null;
      setStatus("idle");
      log("stopping…");
    } catch (e) {
      log("stop error", e);
    }
  };

  // Force the model to speak even if no VAD trigger happened
  btnForce.onclick = () => {
    try {
      if (!dc || dc.readyState !== "open") { log("force: datachannel not open"); return; }
      // optional: tell the server we’re done talking
      dc.send(JSON.stringify({ type: "input_audio_buffer.commit" }));
      // ask for a reply
      const name = (nameInput.value || "").trim();
      const greet = name ? `Say: Hello ${name}. I can hear you.` : "Say: Hello. I can hear you.";
      dc.send(JSON.stringify({
        type: "response.create",
        response: {
          modalities: ["audio"],
          instructions: greet
        }
      }));
      log("force: sent response.create");
    } catch (e) {
      log("force error:", e);
    }
  };

  // boot
  refreshMemoryUI();
})();
</script>
</body>
</html>
