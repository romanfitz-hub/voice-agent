<script>
/* ---------- utilities ---------- */
const $ = sel => document.querySelector(sel);
const logBox = $('#log') || (function(){
  const pre = document.createElement('pre');
  pre.id = 'log';
  pre.style.minHeight = '220px';
  pre.style.padding = '12px';
  pre.style.border = '1px solid #ddd';
  pre.style.borderRadius = '8px';
  pre.style.background = '#f7f7f7';
  pre.style.whiteSpace = 'pre-wrap';
  pre.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
  document.body.appendChild(pre);
  return pre;
})();
function log(...args){ logBox.textContent += args.join(' ') + '\n'; }
function setStatus(s){ const el = $('#status'); if (el) el.textContent = s; }
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* ---------- params ---------- */
const url = new URL(location.href);
const AUTO = url.searchParams.get('auto') === '1';
const DELAY = Number(url.searchParams.get('delay') || 1200); // ms
const MODEL = 'gpt-4o-realtime-preview-2024-12-17'; // or your chosen realtime model

/* ---------- audio widgets ---------- */
const audioEl = $('#audio') || (function(){
  const a = document.createElement('audio');
  a.id = 'audio';
  a.autoplay = true;
  a.playsInline = true;
  document.body.appendChild(a);
  return a;
})();

/* ---------- main connect with retry ---------- */
async function startVoiceAgentOnce() {
  setStatus('connecting…');
  log('fetching client session…');

  // 1) get short-lived client_secret from our server
  const sessRes = await fetch('/session', { method: 'POST' }).catch(e => { throw new Error('session fetch failed: '+e.message); });
  if (!sessRes.ok) {
    const t = await sessRes.text().catch(()=> '');
    throw new Error(`session endpoint error ${sessRes.status} ${t}`);
  }
  const sess = await sessRes.json();
  if (!sess?.client_secret?.value) throw new Error('no client_secret in /session response');

  // 2) set up WebRTC
  const pc = new RTCPeerConnection();
  const ms = await navigator.mediaDevices.getUserMedia({ audio: true });
  for (const track of ms.getTracks()) pc.addTrack(track, ms);
  const remoteStream = new MediaStream();
  pc.ontrack = e => { e.streams[0].getAudioTracks().forEach(t => remoteStream.addTrack(t)); };
  audioEl.srcObject = remoteStream;

  // 3) data channel (optional, but nice to know status)
  const dc = pc.createDataChannel('oai-events');
  dc.onopen = () => log('events channel open');
  dc.onclose = () => log('events channel closed');

  // 4) create and send offer to OpenAI
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  const resp = await fetch(
    `https://api.openai.com/v1/realtime?model=${encodeURIComponent(MODEL)}`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${sess.client_secret.value}`,
        'Content-Type': 'application/sdp'
      },
      body: offer.sdp
    }
  );

  if (resp.status === 401) {
    // Let caller handle as a retry case
    throw Object.assign(new Error('401 from realtime offer'), { code: 401 });
  }
  if (!resp.ok) {
    const errTxt = await resp.text().catch(()=> '');
    throw new Error(`realtime offer failed: ${resp.status} ${errTxt}`);
  }

  const answerSdp = await resp.text();
  await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

  setStatus('connected');
  log('connected ✔️');
}

/* A wrapper that retries once on 401 / token timing issues */
async function startVoiceAgentWithRetry() {
  try {
    await startVoiceAgentOnce();
  } catch (err) {
    const msg = (err && (err.message || err.toString())) || 'unknown';
    log('error:', msg);
    // retry once when the error is clearly auth timing: 401
    if (err && (err.code === 401 || /401/.test(msg))) {
      setStatus('retrying…');
      await sleep(1500);
      try {
        await startVoiceAgentOnce();
        return;
      } catch (err2) {
        log('retry failed:', err2.message || err2);
        setStatus('error');
        throw err2;
      }
    } else {
      setStatus('error');
      throw err;
    }
  }
}

/* ---------- wire up buttons ---------- */
const startBtn = $('#start');
const stopBtn  = $('#stop');
if (startBtn) startBtn.onclick = () => startVoiceAgentWithRetry();
if (stopBtn)  stopBtn.onclick  = () => location.reload();

/* ---------- auto start ---------- */
(async () => {
  // Request mic proactively so iOS autoplay is satisfied
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop());
  } catch (e) {
    // If the user has never granted mic before, iOS will prompt on the real start.
  }

  if (AUTO) {
    setStatus('warming up…');
    await sleep(DELAY);        // give the server a moment to wake and mint the token
    await startVoiceAgentWithRetry();
  } else {
    setStatus('idle');
  }
})();
</script>
