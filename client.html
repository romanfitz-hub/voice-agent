<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Voice Agent — Memory + Realtime (with Notes)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    html, body { width: 100%; max-width: 100%; overflow-x: hidden; }
    :root { --bg:#ffffff; --ink:#111; --muted:#666; --card:#f2f2f2; --line:#e9e9e9; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background: var(--bg); color: var(--ink); }

    header { padding: 18px 22px; border-bottom: 1px solid var(--line); max-width: 1100px; margin: 0 auto; }
    h1 { font-size: 22px; margin: 0 0 4px; }
    .sub { color: var(--muted); font-size: 13px; }

    main { display: grid; grid-template-columns: minmax(0,1fr) 360px; gap: 16px; padding: 16px; max-width: 1100px; margin: 0 auto; }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }

    .panel { background: var(--bg); min-width: 0; }
    .card { background: var(--card); padding:16px; border-radius:12px; margin:12px 0; }
    .row { margin: 10px 0; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input { flex:1; min-width:220px; padding:12px; font-size:16px; border-radius:10px; border:1px solid #ccc; background:#fff; }
    button { padding:12px 16px; border-radius:12px; border:0; background:#e6e6e6; font-size:16px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button.warn { background:#ffecec; }
    .ok { color: #0a8a00; font-weight:600; }
    .err { color: #b00020; font-weight:600; }

    pre { white-space: pre-wrap; background:#fafafa; padding:12px; border-radius:12px; border:1px solid #eee; max-height:34vh; overflow:auto; margin:0;
          overflow-wrap:anywhere; word-break:break-word; }

    small.mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .k { padding:2px 6px; border-radius:6px; background:#f6f6f6; border:1px solid #eee; font-family: ui-monospace, Menlo, Consolas, monospace; }
    .notesHead { display:flex; align-items:center; justify-content:space-between; margin-top:12px; }
    #notesList { max-height: 60vh; overflow:auto; }
    .note { background:#fff; border:1px solid #eee; border-radius:10px; padding:10px; margin:8px 0; }
    .note small { color:#777; display:block; margin-top:6px; }
    .pill { font-size:12px; padding:3px 8px; border-radius:999px; background:#f3f3f3; border:1px solid #e6e6e6; }

    @media (max-width: 520px) {
      .row { flex-direction: column; align-items: stretch; }
      input, button { width: 100%; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Voice Agent — Memory + Realtime</h1>
    <div class="sub">
      Say <span class="k">remember: …</span>. The model will say a line with <span class="k">SAVE_NOTE: …</span> — we’ll save it as a Note.
      Use <span class="k">Force reply</span> if it goes quiet. On <span class="k">Stop</span>, we save a 3-bullet call snapshot.
    </div>
  </header>

  <main>
    <!-- LEFT: Core controls + Profile memory + Logs -->
    <section class="panel">
      <div class="card">
        <div class="row"><b>Your Memory (saved to server)</b></div>
        <div class="row">
          <small class="mono">User ID: <span id="uid"></span></small>
          <button id="copyUid">Copy</button>
          <span class="pill" id="status">idle</span>
        </div>

        <div class="row"><b>Name:</b><input id="name" placeholder="e.g., Roman" /><button id="saveName">Save</button><span id="saveNameStat"></span></div>
        <div class="row"><b>Kids:</b><input id="kids" placeholder="Comma-separated: Ava, Ben, Chris" /><button id="saveKids">Save</button><span id="saveKidsStat"></span></div>
        <div class="row"><b>Tone:</b><input id="tone" placeholder="e.g., witty, concise, encouraging" /><button id="saveTone">Save</button><span id="saveToneStat"></span></div>
        <div class="row"><b>Persona:</b><input id="persona" placeholder="e.g., friendly coach, upbeat coworker" /><button id="savePersona">Save</button><span id="savePersonaStat"></span></div>
      </div>

      <div class="row">
        <button id="beep1">Beep (WebAudio)</button>
        <button id="beep2">Beep (AudioTag)</button>
        <button id="unlock">Unlock mic</button>
      </div>

      <div class="row">
        <button id="start" class="primary">Start voice agent</button>
        <button id="force" disabled>Force reply</button>
        <button id="stop" class="warn" disabled>Stop</button>
      </div>

      <div class="card">
        <b>Log</b>
        <pre id="log"></pre>
      </div>

      <!-- IMPORTANT: this plays the remote audio -->
      <audio id="remoteAudio" autoplay playsinline></audio>
    </section>

    <!-- RIGHT: Notes panel -->
    <aside class="panel">
      <div class="card">
        <div class="notesHead">
          <b>Notes</b>
          <div>
            <button id="refreshNotes">Refresh</button>
            <button id="clearNotes">Clear All</button>
          </div>
        </div>
        <div id="notesList"><div class="sub">No notes yet…</div></div>
        <div class="sub" style="margin-top:8px">
          Examples: <span class="k">remember: order more cups</span>, <span class="k">remember: greet Roman by name</span>.
        </div>
      </div>
    </aside>
  </main>

<script>
/* ========= helpers ========= */
const $ = (id) => document.getElementById(id);
const log = (s) => { $("log").textContent += (s + "\n"); $("log").scrollTop = $("log").scrollHeight; };
const setStatus = (s) => $("status").textContent = s;
const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&gt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

// Stable userId (localStorage) — keeps your memory consistent
function getUserId() {
  let id = localStorage.getItem("dummy_user_id");
  if (!id) { id = crypto.randomUUID(); localStorage.setItem("dummy_user_id", id); }
  return id;
}
const userId = getUserId();
$("uid").textContent = userId;
$("copyUid").onclick = () => navigator.clipboard.writeText(userId);

/* ========= Profile memory UI ========= */
async function loadProfileMemory() {
  try {
    const r = await fetch(`/memory/get?userId=${encodeURIComponent(userId)}`);
    const j = await r.json();
    const m = j.memory || {};
    $("name").value    = m.name    || "";
    $("kids").value    = m.kids    || "";
    $("tone").value    = m.tone    || "";
    $("persona").value = m.persona || "";
  } catch {}
}
async function setMem(key, value, el) {
  try {
    const r = await fetch(`/memory/set?userId=${encodeURIComponent(userId)}&key=${encodeURIComponent(key)}&value=${encodeURIComponent(value)}`);
    const j = await r.json();
    el.className = j.ok ? "ok" : "err";
    el.textContent = j.ok ? "Saved ✓" : "Failed";
    setTimeout(()=>{ el.textContent = ""; el.className=""; }, 2000);
  } catch { el.className="err"; el.textContent="Failed"; }
}
$("saveName").onclick    = () => setMem("name", $("name").value.trim(), $("saveNameStat"));
$("saveKids").onclick    = () => setMem("kids", $("kids").value.trim(), $("saveKidsStat"));
$("saveTone").onclick    = () => setMem("tone", $("tone").value.trim(), $("saveToneStat"));
$("savePersona").onclick = () => setMem("persona", $("persona").value.trim(), $("savePersonaStat"));

/* ========= Notes panel ========= */
const notesState = { items: [] };
let lastSavedNote = ""; // dedupe protection

function renderNotes() {
  const box = $("notesList");
  if (!notesState.items.length) { box.innerHTML = `<div class="sub">No notes yet…</div>`; return; }
  box.innerHTML = notesState.items.map(text => `
    <div class="note">
      <div>${escapeHtml(text)}</div>
      <small>${new Date().toLocaleString()}</small>
    </div>`).join('');
}
async function loadNotes() {
  try {
    const r = await fetch(`/memory/notes/list?userId=${encodeURIComponent(userId)}`);
    const j = await r.json();
    notesState.items = Array.isArray(j.notes) ? j.notes : [];
    renderNotes();
  } catch (e) { log('notes load error: ' + e); }
}
async function addNote(text) {
  const note = String(text || "").trim();
  if (!note || note === lastSavedNote) return;
  try {
    const r = await fetch(`/memory/notes/add`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ userId, text: note })
    });
    if (!r.ok) throw new Error('notes add failed');
    lastSavedNote = note;
    await loadNotes();
    log('NOTE saved: ' + note);
  } catch (e) { log('notes add error: ' + e); }
}
async function clearNotes() {
  try {
    const r = await fetch(`/memory/notes/clear`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ userId })
    });
    if (!r.ok) throw new Error('notes clear failed');
    notesState.items = []; lastSavedNote = "";
    renderNotes();
    log('notes cleared');
  } catch (e) { log('notes clear error: ' + e); }
}
$("refreshNotes").onclick = () => loadNotes();
$("clearNotes").onclick = () => { if (confirm('Clear all notes?')) clearNotes(); };

/* ========= Audio nudges ========= */
$("beep1").onclick = () => {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator(); const g = ctx.createGain();
  osc.frequency.value = 880; g.gain.value = 0.06;
  osc.connect(g).connect(ctx.destination); osc.start();
  setTimeout(()=>{ osc.stop(); ctx.close(); }, 150);
  log("WebAudio beep");
};
$("beep2").onclick = () => {
  const a = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQgAAAAA");
  a.play(); log("AudioTag beep");
};

/* ========= Realtime (WebRTC) ========= */
let pc, dc, micStream;
const remoteAudio = $("remoteAudio");

// Transcript buffer for end-of-call summary (assistant lines)
const transcript = []; // {role:'assistant', text, t}

$("unlock").onclick = async () => {
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    log("microphone OK");
  } catch (e) { log("mic error: " + e); }
};

$("start").onclick = async () => {
  setStatus("starting…"); $("force").disabled = true; $("stop").disabled = false;

  try {
    if (!micStream) micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    // 1) Get ephemeral client_secret + personalized instructions
    log("start: step 3/7 fetch /session");
    const sres = await fetch(`/session?userId=${encodeURIComponent(userId)}`);
    const session = await sres.json();
    if (!session?.client_secret?.value) throw new Error("No client_secret in /session");
    log("start: got session");

    // 2) RTCPeerConnection
    log("start: step 5/7 create RTCPeerConnection");
    pc = new RTCPeerConnection();

    // attach remote audio
    pc.ontrack = (ev) => {
      remoteAudio.srcObject = ev.streams[0];
      log("ontrack: remote audio attached");
    };

    // data channel
    dc = pc.createDataChannel("oai-events");
    dc.onopen = () => { $("force").disabled = false; log("datachannel open"); };

    // === Handle realtime events ===
    dc.onmessage = (e) => {
      let data = e.data;
      try { data = JSON.parse(e.data); } catch { /* sometimes plain text */ }

      // 1) AUDIO transcript deltas (spoken assistant)
      if (data && data.type === 'response.audio_transcript.delta' && typeof data.delta === 'string') {
        // We only save on "done", so no work here (but you could live-preview if you want)
        return;
      }

      // 2) AUDIO transcript done -> capture text, save notes, add to summary buffer
      if (data && data.type === 'response.audio_transcript.done' && typeof data.transcript === 'string') {
        const full = data.transcript.trim();
        if (full) {
          transcript.push({ role:'assistant', text: full, t: Date.now() });
          log("assistant: " + full.slice(0, 500));
          handleSaveNotesFrom(full);
        }
        return;
      }

      // 3) TEXT deltas (if model ever streams text modality)
      if (data && data.type === 'response.output_text.delta' && typeof data.delta === 'string') {
        // If your model ever sends text instead of audio, you can accumulate here.
        // We still prefer the audio transcript for note capture.
        return;
      }

      // Log short
      const raw = typeof e.data === 'string' ? e.data : JSON.stringify(e.data);
      log("event: " + raw.slice(0, 300));
    };

    // send mic
    micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

    // 3) Offer → OpenAI
    log("start: step 6/7 createOffer & setLocalDescription");
    const offer = await pc.createOffer({ offerToReceiveAudio: true });
    await pc.setLocalDescription(offer);

    log("start: step 7/7 POST offer to OpenAI");
    const resp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(session.model)}&voice=verse`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${session.client_secret.value}`,
        "Content-Type": "application/sdp"
      },
      body: offer.sdp
    });

    const answer = { type: "answer", sdp: await resp.text() };
    await pc.setRemoteDescription(answer);

    pc.oniceconnectionstatechange = () => log("pc state: " + pc.iceConnectionState);
    pc.onconnectionstatechange = () => log("ice state: " + pc.connectionState);

    setStatus("listening");
    log("connected ✓ (speak, or tap Force reply)");
  } catch (e) {
    setStatus("idle"); $("force").disabled = true; $("stop").disabled = true;
    log("start error: " + e);
  }
};

// Parse SAVE_NOTE lines only when a full transcript chunk completes
function handleSaveNotesFrom(text) {
  // Capture one or more "SAVE_NOTE: ..." lines in the transcript
  const matches = String(text).match(/SAVE_NOTE:\s*([^\n\r]+)/gi) || [];
  for (const m of matches) {
    const cleaned = m.replace(/^SAVE_NOTE:\s*/i, "").trim();
    if (cleaned) addNote(cleaned);
  }
}

$("force").onclick = () => {
  try {
    if (!dc || dc.readyState !== "open") { log("force: datachannel not open"); return; }
    const name = $("name").value.trim();
    const greet = name ? `Say: Hello ${name}. I can hear you.` : "Say: Hello. I can hear you.";
    dc.send(JSON.stringify({ type: "response.create", response: { modalities: ["audio"], instructions: greet } }));
    log("force: sent response.create");
  } catch (e) { log("force error: " + e); }
};

$("stop").onclick = async () => {
  try {
    setStatus("stopping…");

    // Create end-of-call snapshot (3 bullets) and save as a note
    try {
      const r = await fetch('/summarize', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ userId, transcript })
      });
      const j = await r.json();
      const summary = (j && j.summary) ? String(j.summary).trim() : '';
      if (summary) await addNote(summary);
    } catch (e) {
      log('snapshot failed: ' + e);
    }

    if (dc) dc.close();
    if (pc) pc.close();
    dc = null; pc = null;
    if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
    remoteAudio.srcObject = null;
    $("force").disabled = true; $("stop").disabled = true;
    setStatus("idle");
    log("stopped");
  } catch {}
};

// Boot
loadProfileMemory();
loadNotes();
</script>
</body>
</html>
