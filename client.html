<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Voice Agent – Audio Unlock</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:24px; line-height:1.45; }
  h1 { margin:0 0 12px; font-size:26px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
  button { font-size:16px; padding:10px 14px; border-radius:10px; border:1px solid #bbb; }
  #status { font-weight:700; }
  #log { min-height:220px; border:1px solid #ddd; border-radius:10px; padding:12px; background:#f7f7f7;
         white-space:pre-wrap; overflow:auto; font-family:ui-monospace,SFMono-Regular,Menlo,monospace; }
  .note { opacity:.8; }
</style>
</head>
<body>
<h1>Voice Agent – Audio Unlock</h1>

<div class="row">
  <button id="beep-webaudio">Beep (WebAudio)</button>
  <button id="beep-audio">Beep (AudioTag)</button>
  <button id="nudge">Nudge audio</button>
</div>

<div class="row">
  <button id="start">Start voice agent</button>
  <button id="stop" disabled>Stop</button>
  <button id="force" disabled>Force reply</button>
</div>

<div class="note">Status: <span id="status">idle</span></div>
<audio id="agent-audio" autoplay playsinline></audio>
<pre id="log"></pre>

<script>
const $ = s => document.querySelector(s);
const logEl = $('#log');
function log(...a){ logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function setStatus(s){ $('#status').textContent = s; }

const audioEl = $('#agent-audio');
let pc=null, dc=null, micStream=null, connected=false, starting=false;

/* ---------- Audio unlock helpers ---------- */
async function unlockWithWebAudio(ms = 250) {
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return false;
    const ctx = new AC();
    if (ctx.state === 'suspended') { try { await ctx.resume(); } catch(e){} }
    const osc = ctx.createOscillator(), gain = ctx.createGain();
    gain.gain.value = 0.04; osc.frequency.value = 880;
    osc.connect(gain).connect(ctx.destination);
    osc.start();
    await new Promise(r => setTimeout(r, ms));
    try { osc.stop(); } catch {}
    try { await ctx.close(); } catch {}
    log('WebAudio nudge OK');
    return true;
  } catch (e) {
    log('WebAudio nudge failed:', e?.message || e);
    return false;
  }
}

async function forcePlay(el) {
  try {
    el.muted = false;
    el.playsInline = true;
    const p = el.play();
    if (p && typeof p.then === 'function') await p;
    log('audioEl.play() resolved');
    return true;
  } catch (e) {
    log('audioEl.play() error:', e?.message || e);
    return false;
  }
}

/* ---------- Beep tests ---------- */
$('#beep-webaudio').onclick = async () => {
  log('WebAudio beep');
  await unlockWithWebAudio(400);
};

$('#beep-audio').onclick = async () => {
  log('AudioTag beep: trying');
  try {
    const a = new Audio();
    a.setAttribute('playsinline','');
    // Slightly longer WAV with proper header
    a.src = "data:audio/wav;base64,UklGRkgAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAaGFkYQAAAAAAAP8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP8AAP8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA";
    await a.play();
    log('AudioTag beep: playing');
  } catch (e) {
    log('AudioTag play() error:', e?.message || e);
    alert('AudioTag play() failed: ' + (e?.message || e));
  }
};

$('#nudge').onclick = async () => {
  log('Manual nudge…');
  await unlockWithWebAudio(350);
  await forcePlay(audioEl);
};

/* ---------- Agent controls ---------- */
function updateButtons(){
  $('#start').disabled = connected || starting;
  $('#stop').disabled  = !connected && !starting;
  $('#force').disabled = !connected || dc?.readyState!=='open';
}

async function startAgent(){
  if (starting || connected) { log('start ignored'); return; }
  starting = true; updateButtons();
  try {
    setStatus('preparing…');

    // Pre-unlock audio path before any remote track arrives
    await unlockWithWebAudio(250);
    await forcePlay(audioEl);

    // fetch short-lived client_secret
    const r = await fetch('/session', { method:'POST' });
    if (!r.ok) throw new Error('session error '+r.status);
    const sess = await r.json();
    const token = sess?.client_secret?.value;
    const model = sess?.model || 'gpt-4o-realtime-preview-2024-12-17';
    if (!token) throw new Error('no client_secret');

    // WebRTC
    const pcLocal = new RTCPeerConnection();
    pc = pcLocal;

    const remoteStream = new MediaStream();
    pc.ontrack = async (ev) => {
      ev.streams[0].getAudioTracks().forEach(t => remoteStream.addTrack(t));
      audioEl.srcObject = remoteStream;
      log('remote track attached');

      // Nudge again right after attaching remote stream
      await unlockWithWebAudio(200);
      await forcePlay(audioEl);
    };

    dc = pc.createDataChannel('oai-events');
    dc.onopen = () => { log('datachannel open'); updateButtons(); };
    dc.onclose = () => log('datachannel closed');
    dc.onmessage = ev => { try{const m=JSON.parse(ev.data); if(m?.type) log('event:', m.type); } catch { log('event:', ev.data); } };

    micStream = await navigator.mediaDevices.getUserMedia({ audio:true });
    micStream.getTracks().forEach(t => pc.addTrack(t, micStream));
    pc.addTransceiver('audio', { direction:'recvonly' });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const resp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
      method:'POST',
      headers:{ 'Authorization':'Bearer '+token, 'Content-Type':'application/sdp' },
      body: offer.sdp
    });
    if (resp.status === 401) throw new Error('401 realtime offer');
    if (!resp.ok) throw new Error('realtime offer failed '+resp.status+' '+ await resp.text());

    const answer = await resp.text();
    await pc.setRemoteDescription({ type:'answer', sdp:answer });

    connected = true; setStatus('listening'); updateButtons();
    log('connected ✔️ (waiting for your voice; use Force reply to make it speak)');
  } catch (e) {
    log('start error:', e?.message || e);
    setStatus('error');
  } finally {
    starting = false; updateButtons();
  }
}

function stopAgent(){
  log('stopping…');
  try { dc?.close(); } catch {}
  try { pc?.close(); } catch {}
  try { micStream?.getTracks().forEach(t=>t.stop()); } catch {}
  try { audioEl.srcObject = null; } catch {}
  dc=null; pc=null; micStream=null; connected=false;
  setStatus('idle'); updateButtons();
}

$('#start').onclick = startAgent;
$('#stop').onclick  = stopAgent;
$('#force').onclick = () => { try { dc?.send(JSON.stringify({ type:'response.create' })); } catch{}; };

setStatus('idle'); updateButtons();
</script>
</body>
</html>
