<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realtime Voice Agent</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 24px; line-height: 1.4; }
    h1 { font-size: 2.2rem; margin: 0 0 16px; }
    button { font-size: 16px; padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; margin: 6px 10px 12px 0; }
    #status { font-weight: 700; }
    #log { min-height: 220px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7;
           white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .row { margin: 10px 0; }
  </style>
</head>
<body>
  <h1>Realtime Voice Agent</h1>

  <div class="row">
    <button id="start">Start voice agent</button>
    <button id="stop">Stop</button>
    <button id="ping" title="Force one reply">Force reply</button>
    <button id="beep">Test sound</button>
  </div>

  <div class="row">
    <strong>Output:</strong>
    <button id="clear" title="Clear log">⟳</button>
  </div>

  <div class="row"><strong>Status:</strong> <span id="status">idle</span></div>

  <audio id="audio" autoplay playsinline></audio>
  <pre id="log"></pre>

  <noscript>
    <p>This page requires JavaScript.</p>
  </noscript>

  <script>
  /* ---------- helpers ---------- */
  const $ = s => document.querySelector(s);
  const logBox = $('#log');
  function log(...a){ logBox.textContent += a.join(' ') + "\\n"; logBox.scrollTop = logBox.scrollHeight; }
  function setStatus(s){ const el = $('#status'); if (el) el.textContent = s; }
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  $('#clear').onclick = () => logBox.textContent = '';

  window.addEventListener('error', e => { setStatus('error'); log('window error:', e.message); });

  /* ---------- params ---------- */
  const url = new URL(location.href);
  const AUTO  = url.searchParams.get('auto') === '1';
  const DELAY = Number(url.searchParams.get('delay') || 1200);
  const MODEL = 'gpt-4o-realtime-preview-2024-12-17'; // adjust if needed

  /* ---------- audio ---------- */
  const audioEl = $('#audio');

  /* ---------- main connect flow with a 401 retry ---------- */
  async function startVoiceAgentOnce() {
    setStatus('connecting…'); log('fetching short-lived client_secret…');

    // 1) get a client_secret from our server
    const sessRes = await fetch('/session', { method: 'POST' });
    if (!sessRes.ok) {
      const t = await sessRes.text().catch(()=> '');
      throw new Error('session error ' + sessRes.status + ' ' + t);
    }
    const sess = await sessRes.json();
    const token = sess?.client_secret?.value;
    if (!token) throw new Error('no client_secret in /session response');

    // 2) WebRTC setup
    const pc = new RTCPeerConnection();
    const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
    for (const track of mic.getTracks()) pc.addTrack(track, mic);

    const remote = new MediaStream();
    pc.ontrack = e => { e.streams[0].getAudioTracks().forEach(t => remote.addTrack(t)); };
    audioEl.srcObject = remote;

    const dc = pc.createDataChannel('oai-events');
    dc.onopen = () => log('events channel open');
    dc.onclose = () => log('events channel closed');

    // 3) Offer → OpenAI
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const resp = await fetch('https://api.openai.com/v1/realtime?model=' + encodeURIComponent(MODEL), {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/sdp' },
      body: offer.sdp
    });

    if (resp.status === 401) {
      const e = new Error('401 from realtime offer'); e.code = 401; throw e;
    }
    if (!resp.ok) {
      const t = await resp.text().catch(()=> '');
      throw new Error('realtime offer failed: ' + resp.status + ' ' + t);
    }

    const answerSdp = await resp.text();
    await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

    setStatus('connected'); log('connected ✔️');
  }

  async function startVoiceAgentWithRetry() {
    try {
      await startVoiceAgentOnce();
    } catch (err) {
      log('error:', err.message || err);
      if (err.code === 401 || /401/.test(err.message || '')) {
        setStatus('retrying…'); await sleep(1500);
        try { await startVoiceAgentOnce(); return; }
        catch (e2) { log('retry failed:', e2.message || e2); setStatus('error'); }
      } else {
        setStatus('error');
      }
    }
  }

  /* ---------- UI buttons ---------- */
  $('#start').onclick = () => startVoiceAgentWithRetry();
  $('#stop').onclick  = () => location.reload();
  $('#ping').onclick  = () => alert('This demo uses passive replies; speak after the chime.');
  $('#beep').onclick  = () => { try { new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYBAGZmZmY=').play(); } catch {} };

  /* ---------- auto start on load ---------- */
  (async () => {
    // prime mic permission for iOS
    try { const s = await navigator.mediaDevices.getUserMedia({ audio: true }); s.getTracks().forEach(t=>t.stop()); } catch {}
    if (AUTO) {
      setStatus('warming up…');
      await sleep(DELAY);
      await startVoiceAgentWithRetry();
    } else {
      setStatus('idle');
    }
  })();
  </script>
</body>
</html>
