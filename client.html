<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Voice Agent — Guarded</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:24px; line-height:1.44; }
  h1 { margin:0 0 12px; font-size:26px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
  button { font-size:16px; padding:10px 14px; border-radius:10px; border:1px solid #bbb; }
  button:disabled{ opacity:.6 }
  #status { font-weight:700; }
  #log { min-height:220px; border:1px solid #ddd; border-radius:10px; padding:12px; background:#f7f7f7;
         white-space:pre-wrap; overflow:auto; font-family:ui-monospace,SFMono-Regular,Menlo,monospace; }
  .note { opacity:.8; }
</style>
</head>
<body>
<h1>Voice Agent — Guarded</h1>

<div class="row">
  <button id="beep-wa">Beep (WebAudio)</button>
  <button id="beep-tag">Beep (AudioTag)</button>
  <button id="nudge">Nudge audio</button>
  <button id="unlock-mic">Unlock mic</button>
</div>

<div class="row">
  <button id="start">Start voice agent</button>
  <button id="stop" disabled>Stop</button>
  <button id="force" disabled>Force reply</button>
</div>

<div class="note">Status: <span id="status">idle</span></div>
<audio id="out" autoplay playsinline></audio>
<pre id="log"></pre>

<script>
/* ===== helpers ===== */
const $ = s => document.querySelector(s);
const logEl = $('#log');
function log(...a){ logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function setStatus(s){ $('#status').textContent = s; }
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* ===== global state & guard ===== */
let pc=null, dc=null, localStream=null;
let AGENT_STARTING = false;
let AGENT_STARTED  = false;

/* ===== audio unlock ===== */
let audioCtx;
async function beepWebAudio(ms=150, freq=880){
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx) audioCtx = new AC();
    if(audioCtx.state==='suspended') await audioCtx.resume();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type='sine'; o.frequency.value=freq; g.gain.value=0.08;
    o.connect(g).connect(audioCtx.destination); o.start();
    await sleep(ms); o.stop();
    log('WebAudio beep');
  }catch(e){ log('webaudio error:', e?.message||e); }
}
async function nudgeAudio(){
  await beepWebAudio(60, 1200);
  log('WebAudio nudge OK');
}
function beepAudioTag(){
  try{
    const a = new Audio();
    a.setAttribute('playsinline','');
    a.src = "data:audio/wav;base64,UklGRkgAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAaGFkYQAAAAAAAP8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP8AAP8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA";
    a.play().then(()=>log('AudioTag beep')).catch(err=>log('AudioTag play error:', err));
  }catch(e){ log('AudioTag exception:', e?.message||e); }
}
async function unlockMicOnce(){
  log('requesting microphone…');
  try{
    const s = await navigator.mediaDevices.getUserMedia({ audio:true });
    s.getTracks().forEach(t=>t.stop());
    log('microphone OK');
    return true;
  }catch(err){
    log('mic error:', err?.message||err);
    return false;
  }
}

/* ===== UI state ===== */
function updateButtons(){
  $('#start').disabled = AGENT_STARTING || AGENT_STARTED;
  $('#stop').disabled  = !(AGENT_STARTING || AGENT_STARTED);
  $('#force').disabled = !dc || dc.readyState!=='open';
}

/* ===== start/stop guarded ===== */
async function startAgentOnce(){
  if (AGENT_STARTING || AGENT_STARTED){ log('start ignored (already starting/started)'); return; }
  AGENT_STARTING = true; updateButtons();
  try{
    setStatus('preparing…');

    // 0) make sure output audio is unlocked & mic permission is granted
    await nudgeAudio();
    const micOk = await unlockMicOnce();
    if(!micOk){ setStatus('idle'); return; }

    // 1) fetch short-lived client_secret
    log('fetching short-lived client_secret…');
    const sessResp = await fetch('/session', { method:'POST' });
    if(!sessResp.ok){ throw new Error('session error '+sessResp.status); }
    const sess = await sessResp.json();
    const clientSecret = sess?.client_secret?.value;
    const model = sess?.model || 'gpt-4o-realtime-preview-2024-12-17';
    if(!clientSecret) throw new Error('no client_secret');

    // 2) mic stream for real call
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true });

    // 3) WebRTC
    pc = new RTCPeerConnection();
    pc.onconnectionstatechange = () => log('pc state: '+pc.connectionState);
    pc.oniceconnectionstatechange = () => log('ice state: '+pc.iceConnectionState);
    pc.ontrack = (e)=>{ $('#out').srcObject = e.streams[0]; };

    dc = pc.createDataChannel('oai-events');
    dc.onopen  = () => { log('datachannel open'); updateButtons(); };
    dc.onclose = () => log('datachannel closed');
    dc.onmessage = (ev)=>log('event: '+ev.data);

    for(const t of localStream.getTracks()) pc.addTrack(t, localStream);
    const offer = await pc.createOffer({ offerToReceiveAudio:true });
    await pc.setLocalDescription(offer);

    const answerSDP = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`,{
      method:'POST',
      headers:{ 'Authorization':'Bearer '+clientSecret, 'Content-Type':'application/sdp' },
      body: offer.sdp
    }).then(r=>r.text());

    await pc.setRemoteDescription({ type:'answer', sdp:answerSDP });

    AGENT_STARTED = true;
    setStatus('listening');
    log('connected ✓ (speak to get a reply, or press Force reply)');
    updateButtons();
  }catch(err){
    setStatus('error');
    log('start error:', err?.message||err);
  }finally{
    AGENT_STARTING = false; updateButtons();
  }
}

function stopAgent(){
  log('stopping…');
  try{ dc && dc.close(); }catch{}
  try{ pc && pc.close(); }catch{}
  try{ localStream && localStream.getTracks().forEach(t=>t.stop()); }catch{}
  dc=null; pc=null; localStream=null;
  AGENT_STARTED = false; AGENT_STARTING = false;
  setStatus('idle'); updateButtons();
}

function forceReply(){
  if(!dc || dc.readyState!=='open'){ log('force: channel not open'); return; }
  dc.send(JSON.stringify({ type:'response.create' }));
  log('force reply sent');
}

/* ===== wire UI ===== */
$('#beep-wa').onclick = () => beepWebAudio();
$('#beep-tag').onclick = () => beepAudioTag();
$('#nudge').onclick   = () => nudgeAudio();
$('#unlock-mic').onclick = () => unlockMicOnce();
$('#start').onclick   = () => startAgentOnce();
$('#stop').onclick    = () => stopAgent();
$('#force').onclick   = () => forceReply();

setStatus('idle'); updateButtons();

/* ===== auto-start handler (runs ONCE) ===== */
window.addEventListener('load', async () => {
  const q = new URLSearchParams(location.search);
  if (q.get('auto') === '1') {
    // small delay so Safari finishes painting; then guarded start
    await sleep(400);
    startAgentOnce();
  }
});
</script>
</body>
</html>
